

Given an inorder traversal of a cartesian tree, construct the tree.

 Cartesian tree : is a heap ordered binary tree, where the root is greater than all the elements in the subtree. 

 Note: You may assume that duplicates do not exist in the tree. 


int search(vector<int> &A, int s, int e){
    int m = s;
    for(int i=s+1 ; i<=e ; i++)
        if(A[i]>A[m])   m = i;
    return m;
}
TreeNode* U(vector<int> &A, int s, int e){
    if(s>e)    return NULL;
    int id = search(A, s, e);
    TreeNode* t = (TreeNode* ) malloc(sizeof(TreeNode));
    t->val = A[id];
    t->left = U(A, s, id-1);
    t->right = U(A, id+1, e);
    return t;
}
TreeNode* Solution::buildTree(vector<int> &A) {
    if(A.size()==0)
        return NULL;
    TreeNode* root = U(A, 0, A.size()-1);
    return root;
}