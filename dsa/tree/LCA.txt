/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
int f(TreeNode* A, int B, int C){
    queue<TreeNode*> q;
    if(!A)
        return 0;
    q.push(A);
    int fb=0,fc=0;
    while(!q.empty()){
        TreeNode* t = q.front();
        q.pop();
        if(t->val==B)
            fb=1;
        if(t->val==C)
            fc=1;
        if(t->left) q.push(t->left);
        if(t->right)    q.push(t->right);
    }
    return fb==1 && fc==1;
}
int Ulca(TreeNode* A, int B, int C) {
    if(!A)  return -1;
    if(A->val == B || A->val == C)
        return A->val;
    int l = Ulca(A->left, B, C);
    int r = Ulca(A->right, B, C);
    if(l==-1 && r==-1)  return -1;
    if(l!=-1 && r!=-1)  return A->val;
    return l!=-1?l:r;
}
int Solution::lca(TreeNode* A, int B, int C) {
    int iss = f(A, B, C);
    if(iss==0)
        return -1;
    return Ulca(A, B, C);
}